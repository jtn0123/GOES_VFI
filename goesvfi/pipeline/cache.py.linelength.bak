# TODO: simple SHA‑256 → .npy cache

from __future__ import annotations

import hashlib
import pathlib
from typing import Any, List, Optional, cast

import numpy as np

# Import NDArray and Any for specific typing
from numpy.typing import NDArray

from goesvfi.utils import config  # Import config module
from goesvfi.utils.log import get_logger

LOGGER = get_logger(__name__)

# CACHE_DIR removed, get from config
# CACHE_DIR.mkdir removed, handled by config module


# Include num_intermediate_frames in the hash
def _hash_pair(
    path1: pathlib.Path,
    path2: pathlib.Path,
    model_id: str,
    num_intermediate_frames: int,
) -> str:
    h = hashlib.sha256()
    for p in (path1, path2):
        h.update(p.read_bytes())
    h.update(model_id.encode())
    h.update(str(num_intermediate_frames).encode())
    return h.hexdigest()


# Generate filename for a specific frame index
def _get_cache_filepath(base_key: str, index: int, total_frames: int) -> pathlib.Path:
    # Use zfill to ensure consistent sorting if needed, though direct indexing is used here
    max_digits = len(str(total_frames - 1))
    return (
        config.get_cache_dir()
        / f"{base_key}_k{total_frames}_frame{index:0{max_digits}}.npy"
    )


# Load a list of frames if all exist for the given count
def load_cached(
    path1: pathlib.Path,
    path2: pathlib.Path,
    model_id: str,
    num_intermediate_frames: int,
) -> Optional[List[NDArray[Any]]]:
    LOGGER.debug(
        f"Attempting to load cache for {path1.name}, {path2.name}, model={model_id}, frames={num_intermediate_frames}"
    )
    if num_intermediate_frames <= 0:
        LOGGER.debug("num_intermediate_frames is 0 or less, returning None")
        return None  # Cannot cache zero frames

    base_key = _hash_pair(path1, path2, model_id, num_intermediate_frames)
    frame_paths: List[pathlib.Path] = []
    all_exist = True

    # Check if all expected frame files exist
    LOGGER.debug(
        f"Checking for existence of {num_intermediate_frames} cache files with base key {base_key}"
    )
    for i in range(num_intermediate_frames):
        npy_path = _get_cache_filepath(base_key, i, num_intermediate_frames)
        LOGGER.debug(f"Checking if {npy_path} exists")
        if npy_path.exists():
            frame_paths.append(npy_path)
        else:
            LOGGER.debug(f"Cache file {npy_path} missing")
            all_exist = False
            break  # No need to check further if one is missing

    if all_exist:
        # Load all frames if they all exist
        LOGGER.debug(
            f"All cache files found, attempting to load {len(frame_paths)} files"
        )
        loaded_frames: List[NDArray[Any]] = []
        try:
            for npy_path in frame_paths:
                LOGGER.debug(f"Loading cache file: {npy_path}")
                # Cast assumes loaded array is NDArray[Any]
                loaded_frames.append(cast(NDArray[Any], np.load(npy_path)))
            LOGGER.debug("Successfully loaded all cache files")
            return loaded_frames
        except Exception as e:
            LOGGER.warning(f"Error loading cache files for key {base_key}: {e}")
            return None  # Treat load error as cache miss
    else:
        LOGGER.debug("Not all cache files exist, cache miss")
        return None  # Cache miss if not all files were found


# Save a list of frames as separate files
def save_cache(
    path1: pathlib.Path,
    path2: pathlib.Path,
    model_id: str,
    num_intermediate_frames: int,
    frames: List[NDArray[Any]],
) -> None:
    LOGGER.debug(
        f"Attempting to save cache for {path1.name}, {path2.name}, model={model_id}, frames={num_intermediate_frames}"
    )
    LOGGER.debug(
        f"save_cache - num_intermediate_frames: {num_intermediate_frames} (type: {type(num_intermediate_frames)}), len(frames): {len(frames)} (type: {type(frames)})"
    )
    if not frames or num_intermediate_frames != len(frames):
        LOGGER.warning(
            f"Cache save called with mismatch: num_intermediate_frames={num_intermediate_frames}, len(frames)={len(frames)}"
        )
        LOGGER.debug("save_cache returning early due to mismatch")
        return

    base_key = _hash_pair(path1, path2, model_id, num_intermediate_frames)
    base_key = _hash_pair(path1, path2, model_id, num_intermediate_frames)
    LOGGER.debug(f"Saving {len(frames)} cache files with base key {base_key}")
    try:
        for i, frame in enumerate(frames):
            npy_path = _get_cache_filepath(base_key, i, num_intermediate_frames)
            LOGGER.debug(f"Saving cache file: {npy_path}")
            np.save(npy_path, frame)
        LOGGER.debug("Successfully saved all cache files")
    except Exception as e:
        LOGGER.warning(f"Error saving cache files for key {base_key}: {e}")
