"""
Enhanced user feedback utilities for integrity check tabs.

This module provides improved user feedback functionality, including detailed
progress reporting, error messaging, and status updates for the integrity check system.
"""

import json
import logging
import os
import time
from datetime import datetime, timedelta
from enum import Enum, auto
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

from PyQt6.QtCore import (
    QDateTime,
    QObject,
    QRunnable,
    QSize,
    Qt,
    QThreadPool,
    QTimer,
    pyqtSignal,
)
from PyQt6.QtGui import QColor, QFont, QIcon, QPalette, QPixmap
from PyQt6.QtWidgets import (
    QDialog,
    QDialogButtonBox,
    QFrame,
    QGroupBox,
    QHBoxLayout,
    QLabel,
    QListWidget,
    QMessageBox,
    QPlainTextEdit,
    QProgressBar,
    QPushButton,
    QScrollArea,
    QSplitter,
    QStatusBar,
    QTabWidget,
    QTextEdit,
    QVBoxLayout,
    QWidget,
)

# Configure logging
LOGGER = logging.getLogger(__name__)


class MessageType(Enum):
    """Types of user messages with corresponding visual styling."""

    INFO = auto()
    SUCCESS = auto()
    WARNING = auto()
    ERROR = auto()
    DEBUG = auto()


class FeedbackManager(QObject):
    """
    Central manager for user feedback across the integrity check system.

    This class provides a standardized approach for displaying progress, status messages,
    and error notifications to the user, with consistent styling and behavior.
    """

    # Signals for communication
    message_added = pyqtSignal(str, object)  # message, message_type
    status_updated = pyqtSignal(str, object)  # status_text, message_type
    progress_updated = pyqtSignal(int, int, float)  # current, total, eta
    task_started = pyqtSignal(str)  # task_name
    task_completed = pyqtSignal(str, bool)  # task_name, success
    error_occurred = pyqtSignal(str, str)  # error_title, error_message

    def __init__(self) -> None:
        """Initialize the feedback manager."""
        super().__init__()

        # Create message history
        self._message_history: List[Tuple[str, MessageType, datetime]] = []

        # Create progress tracking
        self._current_task: Optional[str] = None
        self._progress_current: int = 0
        self._progress_total: int = 0
        self._progress_start_time: float = 0

        # Create status tracking
        self._current_status: str = "Ready"
        self._current_status_type: MessageType = MessageType.INFO

        # Notification settings
        self._enable_desktop_notifications: bool = False
        self._enable_sound_alerts: bool = False

        # Load settings from file if available
        self._load_settings()

    def _load_settings(self) -> None:
        """Load user feedback settings from file."""
        settings_path = Path.home() / ".config" / "goes_vfi" / "feedback_settings.json"
        if settings_path.exists():
            try:
                with open(settings_path, "r") as f:
                    settings = json.load(f)
                    self._enable_desktop_notifications = settings.get(
                        "desktop_notifications", False
                    )
                    self._enable_sound_alerts = settings.get("sound_alerts", False)
                    LOGGER.debug("Loaded feedback settings")
            except Exception as e:
                LOGGER.error(f"Error loading feedback settings: {e}")

    def _save_settings(self) -> None:
        """Save user feedback settings to file."""
        settings_path = Path.home() / ".config" / "goes_vfi" / "feedback_settings.json"
        settings_path.parent.mkdir(parents=True, exist_ok=True)

        try:
            settings = {
                "desktop_notifications": self._enable_desktop_notifications,
                "sound_alerts": self._enable_sound_alerts,
            }
            with open(settings_path, "w") as f:
                json.dump(settings, f)
                LOGGER.debug("Saved feedback settings")
        except Exception as e:
            LOGGER.error(f"Error saving feedback settings: {e}")

    def add_message(
        self, message: str, message_type: MessageType = MessageType.INFO
    ) -> None:
        """
        Add a message to the feedback system.

        Args:
            message: Message text
            message_type: Type of message for styling
        """
        # Add to history
        timestamp = datetime.now()
        self._message_history.append((message, message_type, timestamp))

        # Emit signal
        self.message_added.emit(message, message_type)

        # Log message based on type
        if message_type == MessageType.ERROR:
            LOGGER.error(message)
        elif message_type == MessageType.WARNING:
            LOGGER.warning(message)
        elif message_type == MessageType.DEBUG:
            LOGGER.debug(message)
        else:
            LOGGER.info(message)

    def update_status(
        self, status: str, message_type: MessageType = MessageType.INFO
    ) -> None:
        """
        Update the current status message.

        Args:
            status: Status message text
            message_type: Type of message for styling
        """
        self._current_status = status
        self._current_status_type = message_type

        # Emit signal
        self.status_updated.emit(status, message_type)

        # Also add as a regular message for history
        self.add_message(f"Status: {status}", message_type)

    def start_task(self, task_name: str, total_steps: int = 100) -> None:
        """
        Start a new task with progress tracking.

        Args:
            task_name: Name of the task
            total_steps: Total number of steps in the task
        """
        self._current_task = task_name
        self._progress_current = 0
        self._progress_total = total_steps
        self._progress_start_time = time.time()

        # Emit signal
        self.task_started.emit(task_name)

        # Update status
        self.update_status(f"Starting task: {task_name}", MessageType.INFO)

        # Log task start
        LOGGER.info(f"Started task: {task_name} ({total_steps} steps)")

    def update_progress(
        self, current: int, total: Optional[int] = None, message: Optional[str] = None
    ) -> None:
        """
        Update the progress of the current task.

        Args:
            current: Current progress value
            total: Optional new total (if not provided, uses the existing total)
            message: Optional message to display with the progress update
        """
        self._progress_current = current
        if total is not None:
            self._progress_total = total

        # Calculate ETA based on elapsed time and progress
        elapsed = time.time() - self._progress_start_time
        if current > 0 and self._progress_total > 0:
            progress_fraction = current / self._progress_total
            if progress_fraction > 0:
                total_time = elapsed / progress_fraction
                eta = total_time - elapsed
            else:
                eta = 0
        else:
            eta = 0

        # Emit signals
        self.progress_updated.emit(current, self._progress_total, eta)

        # If a message was provided, add it
        if message:
            self.add_message(message, MessageType.INFO)

        # Also update status with percentage
        if self._progress_total > 0:
            percent = int((current / self._progress_total) * 100)

            # Format ETA nicely
            if eta > 0:
                minutes = int(eta / 60)
                seconds = int(eta % 60)
                if minutes > 0:
                    eta_text = f" (ETA: {minutes}m {seconds}s)"
                else:
                    eta_text = f" (ETA: {seconds}s)"
            else:
                eta_text = ""

            task_name = self._current_task or "Task"
            self.update_status(f"{task_name}: {percent}%{eta_text}", MessageType.INFO)

    def complete_task(
        self, success: bool = True, message: Optional[str] = None
    ) -> None:
        """
        Mark the current task as completed.

        Args:
            success: Whether the task completed successfully
            message: Optional completion message
        """
        if not self._current_task:
            return

        task_name = self._current_task
        self._current_task = None

        # Emit signal
        self.task_completed.emit(task_name, success)

        # Update status and add message
        message_type = MessageType.SUCCESS if success else MessageType.ERROR

        if success:
            status = f"Completed task: {task_name}"
            if message:
                status = f"{status} - {message}"
            self.update_status(status, MessageType.SUCCESS)

            # Also add as a regular message
            self.add_message(f"Task completed: {task_name}", MessageType.SUCCESS)

            # Send desktop notification if enabled
            if self._enable_desktop_notifications:
                self._send_desktop_notification(f"Task Completed", status)

            # Play sound if enabled
            if self._enable_sound_alerts:
                self._play_success_sound()

        else:
            status = f"Task failed: {task_name}"
            if message:
                status = f"{status} - {message}"
            self.update_status(status, MessageType.ERROR)

            # Also add as a regular message
            self.add_message(f"Task failed: {task_name}", MessageType.ERROR)

            # Send desktop notification if enabled
            if self._enable_desktop_notifications:
                self._send_desktop_notification(f"Task Failed", status)

            # Play sound if enabled
            if self._enable_sound_alerts:
                self._play_error_sound()

        # Log completion
        if success:
            LOGGER.info(f"Completed task: {task_name}")
        else:
            LOGGER.error(f"Task failed: {task_name}")

    def show_error(
        self, title: str, message: str, details: Optional[str] = None
    ) -> None:
        """
        Show an error message to the user.

        Args:
            title: Error dialog title
            message: Error message text
            details: Optional detailed error information
        """
        # Emit signal
        self.error_occurred.emit(title, message)

        # Add as error message
        self.add_message(f"Error: {message}", MessageType.ERROR)

        # Update status
        self.update_status(f"Error: {message}", MessageType.ERROR)

        # Log error
        if details:
            LOGGER.error(f"{title}: {message}\nDetails: {details}")
        else:
            LOGGER.error(f"{title}: {message}")

        # Play sound if enabled
        if self._enable_sound_alerts:
            self._play_error_sound()

    def get_message_history(self) -> List[Tuple[str, MessageType, datetime]]:
        """Get the complete message history."""
        return self._message_history.copy()

    def clear_message_history(self) -> None:
        """Clear the message history."""
        self._message_history.clear()
        LOGGER.debug("Cleared message history")

    def set_desktop_notifications(self, enabled: bool) -> None:
        """
        Enable or disable desktop notifications.

        Args:
            enabled: Whether to enable desktop notifications
        """
        self._enable_desktop_notifications = enabled
        self._save_settings()
        LOGGER.debug(f"Desktop notifications {'enabled' if enabled else 'disabled'}")

    def set_sound_alerts(self, enabled: bool) -> None:
        """
        Enable or disable sound alerts.

        Args:
            enabled: Whether to enable sound alerts
        """
        self._enable_sound_alerts = enabled
        self._save_settings()
        LOGGER.debug(f"Sound alerts {'enabled' if enabled else 'disabled'}")

    def _send_desktop_notification(self, title: str, message: str) -> None:
        """
        Send a desktop notification using the platform-specific method.

        Args:
            title: Notification title
            message: Notification message
        """
        # Attempt to use platform-specific notification method
        try:
            if os.name == "nt":  # Windows
                # Import only when needed
                import win10toast

                toaster = win10toast.ToastNotifier()
                toaster.show_toast(title, message, duration=5)

            elif os.name == "posix":  # macOS or Linux
                if os.uname().sysname == "Darwin":  # macOS
                    # Use AppleScript for notifications
                    os.system(
                        f"""
                        osascript -e 'display notification "{message}" with title "{title}"'
                    """
                    )
                else:  # Linux
                    # Try to use notify-send
                    os.system(f'notify-send "{title}" "{message}"')

        except Exception as e:
            LOGGER.error(f"Error sending desktop notification: {e}")

    def _play_success_sound(self) -> None:
        """Play a success sound alert."""
        try:
            if os.name == "nt":  # Windows
                import winsound

                winsound.MessageBeep(winsound.MB_OK)

            elif os.name == "posix":  # macOS or Linux
                if os.uname().sysname == "Darwin":  # macOS
                    # Use afplay for sound on macOS
                    os.system("afplay /System/Library/Sounds/Glass.aiff")
                else:  # Linux
                    # Try to use paplay if available
                    os.system(
                        "paplay /usr/share/sounds/freedesktop/stereo/complete.oga"
                    )

        except Exception as e:
            LOGGER.error(f"Error playing success sound: {e}")

    def _play_error_sound(self) -> None:
        """Play an error sound alert."""
        try:
            if os.name == "nt":  # Windows
                import winsound

                winsound.MessageBeep(winsound.MB_ICONHAND)

            elif os.name == "posix":  # macOS or Linux
                if os.uname().sysname == "Darwin":  # macOS
                    # Use afplay for sound on macOS
                    os.system("afplay /System/Library/Sounds/Basso.aiff")
                else:  # Linux
                    # Try to use paplay if available
                    os.system(
                        "paplay /usr/share/sounds/freedesktop/stereo/dialog-error.oga"
                    )

        except Exception as e:
            LOGGER.error(f"Error playing error sound: {e}")


class EnhancedStatusBar(QStatusBar):
    """
    Enhanced status bar with improved visual feedback.

    This class extends QStatusBar with improved visual styling and the ability
    to display different types of messages with appropriate styling.
    """

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        """
        Initialize the enhanced status bar.

        Args:
            parent: Optional parent widget
        """
        super().__init__(parent)

        # Set minimum height for better visibility
        self.setMinimumHeight(30)

        # Set fixed height to prevent resizing
        self.setFixedHeight(30)

        # Apply styling
        self.setStyleSheet(
            """
            QStatusBar {
                background-color: #2d2d2d;
                color: #e0e0e0;
                border-top: 1px solid #3a3a3a;
                padding: 4px;
            }
        """
        )

        # Create a label for the status message with eliding
        self.status_label = QLabel("Ready")
        self.status_label.setTextFormat(Qt.TextFormat.RichText)
        self.addWidget(self.status_label, 1)  # Stretch to fill width

        # Create a progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setMaximumWidth(150)
        self.progress_bar.setMaximumHeight(16)
        self.progress_bar.setFormat("%p%")
        self.progress_bar.setStyleSheet(
            """
            QProgressBar {
                border: 1px solid #555;
                border-radius: 2px;
                background-color: #333;
                text-align: center;
                height: 16px;
            }
            QProgressBar::chunk {
                background-color: #3498db;
                border-radius: 1px;
            }
        """
        )
        self.addPermanentWidget(self.progress_bar)

        # Hide progress bar by default
        self.progress_bar.hide()

    def update_status(
        self, message: str, message_type: MessageType = MessageType.INFO
    ) -> None:
        """
        Update the status message with appropriate styling.

        Args:
            message: Status message text
            message_type: Type of message for styling
        """
        # Set color based on message type
        color = "#e0e0e0"  # Default color (info)

        if message_type == MessageType.SUCCESS:
            color = "#2ecc71"  # Green
        elif message_type == MessageType.WARNING:
            color = "#f39c12"  # Orange
        elif message_type == MessageType.ERROR:
            color = "#e74c3c"  # Red
        elif message_type == MessageType.DEBUG:
            color = "#3498db"  # Blue

        # Format message with color
        formatted_message = f"<span style='color: {color};'>{message}</span>"

        # Update label
        self.status_label.setText(formatted_message)

    def show_progress(self, current: int, total: int) -> None:
        """
        Show and update the progress bar.

        Args:
            current: Current progress value
            total: Total progress value
        """
        # Show progress bar if hidden
        if not self.progress_bar.isVisible():
            self.progress_bar.show()

        # Calculate percentage
        if total > 0:
            percent = int((current / total) * 100)
        else:
            percent = 0

        # Update progress bar
        self.progress_bar.setValue(percent)

        # Update format to show values
        self.progress_bar.setFormat(f"{percent}% ({current}/{total})")

    def hide_progress(self) -> None:
        """Hide the progress bar."""
        self.progress_bar.hide()

        # Reset to default value
        self.progress_bar.setValue(0)
        self.progress_bar.setFormat("%p%")


class MessageLogDialog(QDialog):
    """
    Dialog for displaying the message history log.

    This dialog shows the complete message history with filtering options
    and the ability to copy messages to the clipboard.
    """

    def __init__(
        self, feedback_manager: FeedbackManager, parent: Optional[QWidget] = None
    ) -> None:
        """
        Initialize the message log dialog.

        Args:
            feedback_manager: FeedbackManager instance to get messages from
            parent: Optional parent widget
        """
        super().__init__(parent)

        self.feedback_manager = feedback_manager

        # Set up dialog properties
        self.setWindowTitle("Message History")
        self.setMinimumSize(600, 400)

        # Create layout
        layout = QVBoxLayout(self)

        # Create filter options
        filter_layout = QHBoxLayout()

        # Create filter checkboxes for message types
        self.info_checkbox = QPushButton("Info")
        self.info_checkbox.setCheckable(True)
        self.info_checkbox.setChecked(True)
        self.info_checkbox.setStyleSheet(
            "QPushButton:checked { background-color: #3498db; }"
        )
        filter_layout.addWidget(self.info_checkbox)

        self.success_checkbox = QPushButton("Success")
        self.success_checkbox.setCheckable(True)
        self.success_checkbox.setChecked(True)
        self.success_checkbox.setStyleSheet(
            "QPushButton:checked { background-color: #2ecc71; }"
        )
        filter_layout.addWidget(self.success_checkbox)

        self.warning_checkbox = QPushButton("Warnings")
        self.warning_checkbox.setCheckable(True)
        self.warning_checkbox.setChecked(True)
        self.warning_checkbox.setStyleSheet(
            "QPushButton:checked { background-color: #f39c12; }"
        )
        filter_layout.addWidget(self.warning_checkbox)

        self.error_checkbox = QPushButton("Errors")
        self.error_checkbox.setCheckable(True)
        self.error_checkbox.setChecked(True)
        self.error_checkbox.setStyleSheet(
            "QPushButton:checked { background-color: #e74c3c; }"
        )
        filter_layout.addWidget(self.error_checkbox)

        self.debug_checkbox = QPushButton("Debug")
        self.debug_checkbox.setCheckable(True)
        self.debug_checkbox.setChecked(False)
        self.debug_checkbox.setStyleSheet(
            "QPushButton:checked { background-color: #9b59b6; }"
        )
        filter_layout.addWidget(self.debug_checkbox)

        # Add filter layout to main layout
        layout.addLayout(filter_layout)

        # Create message list
        self.message_list = QListWidget()
        self.message_list.setAlternatingRowColors(True)
        self.message_list.setStyleSheet(
            """
            QListWidget {
                background-color: #1d1d1d;
                alternate-background-color: #252525;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
            }
            QListWidget::item {
                padding: 4px;
                border-bottom: 1px solid #333;
            }
        """
        )
        layout.addWidget(self.message_list, 1)  # Give stretch priority

        # Create buttons
        button_layout = QHBoxLayout()

        self.copy_button = QPushButton("Copy Selected")
        self.copy_button.clicked.connect(self._copy_selected)
        button_layout.addWidget(self.copy_button)

        self.copy_all_button = QPushButton("Copy All")
        self.copy_all_button.clicked.connect(self._copy_all)
        button_layout.addWidget(self.copy_all_button)

        self.clear_button = QPushButton("Clear History")
        self.clear_button.clicked.connect(self._clear_history)
        button_layout.addWidget(self.clear_button)

        button_layout.addStretch()

        self.close_button = QPushButton("Close")
        self.close_button.clicked.connect(self.accept)
        button_layout.addWidget(self.close_button)

        layout.addLayout(button_layout)

        # Connect filter checkboxes
        self.info_checkbox.toggled.connect(self._update_message_list)
        self.success_checkbox.toggled.connect(self._update_message_list)
        self.warning_checkbox.toggled.connect(self._update_message_list)
        self.error_checkbox.toggled.connect(self._update_message_list)
        self.debug_checkbox.toggled.connect(self._update_message_list)

        # Initially populate message list
        self._update_message_list()

    def _update_message_list(self) -> None:
        """Update the message list based on current filters."""
        # Clear current list
        self.message_list.clear()

        # Get message history
        messages = self.feedback_manager.get_message_history()

        # Get filter states
        show_info = self.info_checkbox.isChecked()
        show_success = self.success_checkbox.isChecked()
        show_warning = self.warning_checkbox.isChecked()
        show_error = self.error_checkbox.isChecked()
        show_debug = self.debug_checkbox.isChecked()

        # Filter and display messages
        for message, message_type, timestamp in messages:
            # Apply filter
            if (
                message_type == MessageType.INFO
                and not show_info
                or message_type == MessageType.SUCCESS
                and not show_success
                or message_type == MessageType.WARNING
                and not show_warning
                or message_type == MessageType.ERROR
                and not show_error
                or message_type == MessageType.DEBUG
                and not show_debug
            ):
                continue

            # Format timestamp
            timestamp_str = timestamp.strftime("%H:%M:%S")

            # Create item text
            item_text = f"[{timestamp_str}] {message}"

            # Add item to list
            item = self.message_list.addItem(item_text)

            # Set item color based on message type
            list_item = self.message_list.item(self.message_list.count() - 1)

            if message_type == MessageType.SUCCESS:
                list_item.setForeground(QColor("#2ecc71"))  # Green
            elif message_type == MessageType.WARNING:
                list_item.setForeground(QColor("#f39c12"))  # Orange
            elif message_type == MessageType.ERROR:
                list_item.setForeground(QColor("#e74c3c"))  # Red
            elif message_type == MessageType.DEBUG:
                list_item.setForeground(QColor("#3498db"))  # Blue

    def _copy_selected(self) -> None:
        """Copy selected messages to clipboard."""
        selected_items = self.message_list.selectedItems()
        if not selected_items:
            return

        # Create text from selected items
        text = "\n".join(item.text() for item in selected_items)

        # Copy to clipboard
        clipboard = QApplication.clipboard()
        clipboard.setText(text)

        # Show confirmation
        self.feedback_manager.add_message(
            "Selected messages copied to clipboard", MessageType.INFO
        )

    def _copy_all(self) -> None:
        """Copy all displayed messages to clipboard."""
        if self.message_list.count() == 0:
            return

        # Create text from all items
        text = "\n".join(
            self.message_list.item(i).text() for i in range(self.message_list.count())
        )

        # Copy to clipboard
        clipboard = QApplication.clipboard()
        clipboard.setText(text)

        # Show confirmation
        self.feedback_manager.add_message(
            "All messages copied to clipboard", MessageType.INFO
        )

    def _clear_history(self) -> None:
        """Clear the message history."""
        # Show confirmation dialog
        reply = QMessageBox.question(
            self,
            "Clear History",
            "Are you sure you want to clear the message history?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No,
        )

        if reply == QMessageBox.StandardButton.Yes:
            # Clear history
            self.feedback_manager.clear_message_history()

            # Update display
            self.message_list.clear()


class EnhancedProgressDialog(QDialog):
    """
    Enhanced progress dialog with detailed information and cancelability.

    This dialog shows detailed progress information and allows the user to cancel
    the operation if it supports cancellation.
    """

    def __init__(self, title: str, parent: Optional[QWidget] = None) -> None:
        """
        Initialize the enhanced progress dialog.

        Args:
            title: Dialog title
            parent: Optional parent widget
        """
        super().__init__(parent)

        # Set dialog properties
        self.setWindowTitle(title)
        self.setMinimumWidth(500)
        self.setMinimumHeight(250)

        # Set modal flag
        self.setWindowModality(Qt.WindowModality.ApplicationModal)

        # Set auto-deletion when closed
        self.setAttribute(Qt.WidgetAttribute.WA_DeleteOnClose, True)

        # Create layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)

        # Task title
        self.task_label = QLabel(title)
        self.task_label.setStyleSheet("font-size: 14px; font-weight: bold;")
        layout.addWidget(self.task_label)

        # Task description
        self.description_label = QLabel("Preparing...")
        self.description_label.setWordWrap(True)
        layout.addWidget(self.description_label)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setFormat("%p% (%v/%m)")
        self.progress_bar.setStyleSheet(
            """
            QProgressBar {
                border: 1px solid #555;
                border-radius: 4px;
                background-color: #333;
                text-align: center;
                height: 20px;
            }
            QProgressBar::chunk {
                background-color: #3498db;
                border-radius: 3px;
            }
        """
        )
        layout.addWidget(self.progress_bar)

        # ETA label
        self.eta_label = QLabel("Estimated time remaining: Calculating...")
        layout.addWidget(self.eta_label)

        # Create log widget for detailed progress
        log_group = QGroupBox("Progress Details")
        log_layout = QVBoxLayout(log_group)

        self.log_widget = QPlainTextEdit()
        self.log_widget.setReadOnly(True)
        self.log_widget.setMaximumHeight(100)
        self.log_widget.setStyleSheet(
            """
            QPlainTextEdit {
                background-color: #1d1d1d;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                font-family: monospace;
                font-size: 11px;
            }
        """
        )
        log_layout.addWidget(self.log_widget)

        layout.addWidget(log_group)

        # Add spacer
        layout.addStretch()

        # Create buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()

        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self._cancel_clicked)
        button_layout.addWidget(self.cancel_button)

        layout.addLayout(button_layout)

        # Initialize state
        self._is_cancellable = True
        self._is_canceled = False
        self._cancel_callback: Optional[Callable[[], None]] = None

    def set_progress(self, current: int, total: int) -> None:
        """
        Update the progress bar.

        Args:
            current: Current progress value
            total: Total progress value
        """
        # Calculate percentage
        if total > 0:
            percent = int((current / total) * 100)
        else:
            percent = 0

        # Update progress bar
        self.progress_bar.setMaximum(total)
        self.progress_bar.setValue(current)

    def set_description(self, description: str) -> None:
        """
        Update the task description.

        Args:
            description: Task description text
        """
        self.description_label.setText(description)

    def set_eta(self, seconds: float) -> None:
        """
        Update the estimated time remaining.

        Args:
            seconds: Estimated time remaining in seconds
        """
        if seconds <= 0:
            self.eta_label.setText("Estimated time remaining: Calculating...")
            return

        # Format time nicely
        if seconds < 60:
            eta_text = f"Estimated time remaining: {int(seconds)} seconds"
        elif seconds < 3600:
            minutes = int(seconds / 60)
            seconds_left = int(seconds % 60)
            eta_text = f"Estimated time remaining: {minutes}m {seconds_left}s"
        else:
            hours = int(seconds / 3600)
            minutes = int((seconds % 3600) / 60)
            eta_text = f"Estimated time remaining: {hours}h {minutes}m"

        self.eta_label.setText(eta_text)

    def add_log_message(self, message: str) -> None:
        """
        Add a message to the log widget.

        Args:
            message: Log message text
        """
        # Add timestamp
        timestamp = datetime.now().strftime("%H:%M:%S")
        formatted_message = f"[{timestamp}] {message}"

        # Add to log
        self.log_widget.appendPlainText(formatted_message)

        # Scroll to bottom
        self.log_widget.verticalScrollBar().setValue(
            self.log_widget.verticalScrollBar().maximum()
        )

    def set_cancellable(
        self, cancellable: bool, cancel_callback: Optional[Callable[[], None]] = None
    ) -> None:
        """
        Set whether the operation can be canceled.

        Args:
            cancellable: Whether the operation can be canceled
            cancel_callback: Optional callback to call when cancel is clicked
        """
        self._is_cancellable = cancellable
        self._cancel_callback = cancel_callback

        # Update cancel button
        self.cancel_button.setEnabled(cancellable)
        self.cancel_button.setText("Cancel" if cancellable else "Cannot Cancel")

    def is_canceled(self) -> bool:
        """Check if the operation has been canceled."""
        return self._is_canceled

    def _cancel_clicked(self) -> None:
        """Handle cancel button click."""
        if not self._is_cancellable:
            return

        # Update state
        self._is_canceled = True

        # Update UI
        self.cancel_button.setEnabled(False)
        self.cancel_button.setText("Canceling...")

        # Add log message
        self.add_log_message("Cancellation requested.")

        # Set description
        self.set_description("Canceling operation...")

        # Call callback if provided
        if self._cancel_callback:
            self._cancel_callback()


# Module-level feedback manager instance for singleton usage
feedback_manager = FeedbackManager()


def get_feedback_manager() -> FeedbackManager:
    """Get the singleton feedback manager instance."""
    return feedback_manager
