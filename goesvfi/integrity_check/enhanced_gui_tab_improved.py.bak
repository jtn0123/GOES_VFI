"""Enhanced GUI tab for integrity checking with streamlined UI.

This module provides an improved version of the EnhancedIntegrityCheckTab with a
more streamlined and user-friendly interface.
"""

import os
import time
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple, Union, cast

from PyQt6.QtCore import (
    QAbstractTableModel,
    QDate,
    QDateTime,
    QModelIndex,
    QObject,
    QPoint,
    QRunnable,
    QSize,
    QSortFilterProxyModel,
    Qt,
    QThread,
    QThreadPool,
    QTime,
    QTimer,
    pyqtSignal,
)
from PyQt6.QtGui import (
    QAction,
    QBrush,
    QCloseEvent,
    QColor,
    QFont,
    QIcon,
    QPalette,
    QPixmap,
    QStandardItem,
    QStandardItemModel,
)
from PyQt6.QtWidgets import (
    QApplication,
    QCalendarWidget,
    QCheckBox,
    QComboBox,
    QDateTimeEdit,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QFormLayout,
    QFrame,
    QGridLayout,
    QGroupBox,
    QHBoxLayout,
    QHeaderView,
    QLabel,
    QLineEdit,
    QMenu,
    QMessageBox,
    QProgressBar,
    QProgressDialog,
    QPushButton,
    QRadioButton,
    QScrollArea,
    QSizePolicy,
    QSpinBox,
    QSplitter,
    QStackedWidget,
    QStyle,
    QTableView,
    QTabWidget,
    QTextBrowser,
    QTextEdit,
    QToolButton,
    QToolTip,
    QVBoxLayout,
    QWidget,
)

from goesvfi.utils import log

from .enhanced_imagery_tab import EnhancedGOESImageryTab
from .enhanced_view_model import (
    EnhancedIntegrityCheckViewModel,
    EnhancedMissingTimestamp,
    FetchSource,
)
from .gui_tab import CacheInfoDialog, IntegrityCheckTab, MissingTimestampsModel
from .time_index import SatellitePattern, TimeIndex
from .view_model import MissingTimestamp, ScanStatus

LOGGER = log.get_logger(__name__)


class EnhancedMissingTimestampsModel(MissingTimestampsModel):
    """Enhanced model for displaying missing timestamps with source information."""

    def __init__(self, parent: Optional[QObject] = None) -> None:
        super().__init__(parent)
        self._headers = [
            "Timestamp",
            "Satellite",
            "Source",
            "Status",
            "Progress",
            "Path",
        ]

    def data(self, index: QModelIndex, role: int = Qt.ItemDataRole.DisplayRole) -> Any:
        """Return data for the specified index and role."""
        if not index.isValid() or not (0 <= index.row() < len(self._items)):
            return None

        item = cast(EnhancedMissingTimestamp, self._items[index.row()])
        col = index.column()

        if role == Qt.ItemDataRole.DisplayRole:
            if col == 0:  # Timestamp
                return item.timestamp.strftime("%Y-%m-%d %H:%M:%S")
            elif col == 1:  # Satellite
                return item.satellite if isinstance(item.satellite, str) else "Unknown"
            elif col == 2:  # Source
                return item.source.upper() if item.source else "AUTO"
            elif col == 3:  # Status
                if item.is_downloaded:
                    return "Downloaded"
                elif item.is_downloading:
                    return "Downloading..."
                elif item.download_error:
                    # Format error message to be more user-friendly
                    error_msg = item.download_error

                    # Extract error code if present
                    error_code = "Unknown"
                    if "[Error " in error_msg and "]" in error_msg:
                        try:
                            error_code = error_msg.split("[Error ")[1].split("]")[0]
                            # Keep just the error code part for display
                            error_msg = f"Error {error_code}"
                        except:
                            pass

                    # Handle SQLite thread errors specially
                    if "SQLite objects created in a thread" in error_msg:
                        return "Error: Database thread conflict"

                    # Handle common error types with user-friendly messages
                    if (
                        "unable to connect" in error_msg.lower()
                        or "connection" in error_msg.lower()
                    ):
                        return "Error: Connection failed"
                    elif "not found" in error_msg.lower() or "404" in error_msg:
                        return "Error: File not found"
                    elif (
                        "permission" in error_msg.lower()
                        or "access denied" in error_msg.lower()
                    ):
                        return "Error: Access denied"
                    elif "timeout" in error_msg.lower():
                        return "Error: Connection timeout"
                    elif "service" in error_msg.lower():
                        return "Error: Service unavailable"
                    elif "unexpected" in error_msg.lower():
                        # Show a simpler version of unexpected errors
                        return f"Error: Download failed ({error_code})"

                    # If we get here, use a simpler version of the error
                    if len(error_msg) > 50:
                        return f"Error: {error_msg[:47]}..."
                    return f"Error: {error_msg}"
                else:
                    return "Missing"
            elif col == 4:  # Progress
                if item.is_downloading:
                    return f"{item.progress}%"
                elif item.is_downloaded:
                    return "100%"
                else:
                    return ""
            elif col == 5:  # Path
                if item.local_path:
                    # Shorten the path for display purposes
                    path = Path(item.local_path)
                    if len(str(path)) > 40:
                        # Show just the filename and parent directory
                        return f".../{path.parent.name}/{path.name}"
                    return str(path)
                else:
                    return ""

        elif role == Qt.ItemDataRole.ToolTipRole:
            # Add tooltips with more details for certain columns
            if col == 3 and item.download_error:  # Status column with error
                # Create a more detailed tooltip that shows the full error message
                tooltip = "Double-click for details\n\n"

                # Add the error message, but limit length for very long ones
                if len(item.download_error) > 500:
                    tooltip += item.download_error[:500] + "...\n\n"
                else:
                    tooltip += item.download_error + "\n\n"

                # Add a hint about viewing more details
                tooltip += "Right-click to show context menu with more options"
                return tooltip

            elif col == 0:  # Timestamp column
                # Show full ISO format with TZ info in tooltip
                return item.timestamp.isoformat()

            elif col == 5 and item.local_path:  # Path column with content
                # Show "Double-click to open" for downloaded files
                if item.is_downloaded:
                    return f"Double-click to open folder containing:\n{item.local_path}"

        elif role == Qt.ItemDataRole.BackgroundRole:
            if col == 3:  # Status column
                if item.is_downloaded:
                    return QColor(0, 120, 0)  # Dark green for dark mode
                elif item.download_error:
                    return QColor(120, 0, 0)  # Dark red for dark mode
                elif item.is_downloading:
                    return QColor(0, 0, 120)  # Dark blue for dark mode

        # For dark mode, we want to ensure text is visible against colored backgrounds
        elif role == Qt.ItemDataRole.ForegroundRole:
            if col == 3:  # Status column
                if item.is_downloaded or item.download_error or item.is_downloading:
                    return QColor(
                        255, 255, 255
                    )  # White text for better visibility on colored backgrounds

        return None


class QuickDateDialog(QDialog):
    """Dialog for quick date selection with presets."""

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)

        self.start_date = datetime.now() - timedelta(days=1)
        self.end_date = datetime.now()

        self.setWindowTitle("Select Date Range")
        self.setMinimumWidth(400)

        # Create layout
        layout = QVBoxLayout(self)

        # Calendar for date picking
        calendar_group = QGroupBox("Custom Date Selection")
        calendar_layout = QVBoxLayout()

        self.calendar = QCalendarWidget()
        self.calendar.setGridVisible(True)
        self.calendar.setVerticalHeaderFormat(
            QCalendarWidget.VerticalHeaderFormat.NoVerticalHeader
        )
        calendar_layout.addWidget(self.calendar)

        # Time selection
        time_layout = QHBoxLayout()
        time_layout.addWidget(QLabel("Start Time:"))
        from PyQt6.QtCore import QTime
        from PyQt6.QtWidgets import QTimeEdit

        self.start_time_edit = QTimeEdit()
        self.start_time_edit.setDisplayFormat("HH:mm")
        self.start_time_edit.setTime(QTime(0, 0))
        time_layout.addWidget(self.start_time_edit)

        time_layout.addWidget(QLabel("End Time:"))
        self.end_time_edit = QTimeEdit()
        self.end_time_edit.setDisplayFormat("HH:mm")
        self.end_time_edit.setTime(QTime(23, 59))
        time_layout.addWidget(self.end_time_edit)

        calendar_layout.addLayout(time_layout)
        calendar_group.setLayout(calendar_layout)
        layout.addWidget(calendar_group)

        # Quick select buttons
        presets_group = QGroupBox("Quick Presets")
        presets_layout = QGridLayout()

        self.today_btn = QPushButton("Today")
        self.today_btn.clicked.connect(self._set_today)

        self.yesterday_btn = QPushButton("Yesterday")
        self.yesterday_btn.clicked.connect(self._set_yesterday)

        self.last_week_btn = QPushButton("Last 7 Days")
        self.last_week_btn.clicked.connect(self._set_last_week)

        self.last_month_btn = QPushButton("Last 30 Days")
        self.last_month_btn.clicked.connect(self._set_last_month)

        presets_layout.addWidget(self.today_btn, 0, 0)
        presets_layout.addWidget(self.yesterday_btn, 0, 1)
        presets_layout.addWidget(self.last_week_btn, 1, 0)
        presets_layout.addWidget(self.last_month_btn, 1, 1)

        presets_group.setLayout(presets_layout)
        layout.addWidget(presets_group)

        # Buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self._accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)

        # Set default to yesterday
        self._set_yesterday()

    def _set_today(self) -> None:
        """Set the date range to today."""
        today = datetime.now()
        today_start = today.replace(hour=0, minute=0, second=0, microsecond=0)
        today_end = today.replace(hour=23, minute=59, second=59, microsecond=0)

        self.calendar.setSelectedDate(QDate(today.year, today.month, today.day))
        self.start_time_edit.setTime(QTime(0, 0))
        self.end_time_edit.setTime(QTime(23, 59))

        self.start_date = today_start
        self.end_date = today_end

    def _set_yesterday(self) -> None:
        """Set the date range to yesterday."""
        yesterday = datetime.now() - timedelta(days=1)
        yesterday_start = yesterday.replace(hour=0, minute=0, second=0, microsecond=0)
        yesterday_end = yesterday.replace(hour=23, minute=59, second=59, microsecond=0)

        self.calendar.setSelectedDate(
            QDate(yesterday.year, yesterday.month, yesterday.day)
        )
        self.start_time_edit.setTime(QTime(0, 0))
        self.end_time_edit.setTime(QTime(23, 59))

        self.start_date = yesterday_start
        self.end_date = yesterday_end

    def _set_last_week(self) -> None:
        """Set the date range to the last 7 days."""
        today = datetime.now()
        last_week = today - timedelta(days=7)

        last_week_start = last_week.replace(hour=0, minute=0, second=0, microsecond=0)
        today_end = today.replace(hour=23, minute=59, second=59, microsecond=0)

        self.calendar.setSelectedDate(
            QDate(last_week.year, last_week.month, last_week.day)
        )
        self.start_time_edit.setTime(QTime(0, 0))
        self.end_time_edit.setTime(QTime(23, 59))

        self.start_date = last_week_start
        self.end_date = today_end

    def _set_last_month(self) -> None:
        """Set the date range to the last 30 days."""
        today = datetime.now()
        last_month = today - timedelta(days=30)

        last_month_start = last_month.replace(hour=0, minute=0, second=0, microsecond=0)
        today_end = today.replace(hour=23, minute=59, second=59, microsecond=0)

        self.calendar.setSelectedDate(
            QDate(last_month.year, last_month.month, last_month.day)
        )
        self.start_time_edit.setTime(QTime(0, 0))
        self.end_time_edit.setTime(QTime(23, 59))

        self.start_date = last_month_start
        self.end_date = today_end

    def _accept(self) -> None:
        """Handle dialog acceptance and set the selected date range."""
        selected_date = self.calendar.selectedDate()
        selected_day = datetime(
            selected_date.year(), selected_date.month(), selected_date.day()
        )

        start_time = self.start_time_edit.time()
        end_time = self.end_time_edit.time()

        self.start_date = selected_day.replace(
            hour=start_time.hour(), minute=start_time.minute()
        )

        self.end_date = selected_day.replace(
            hour=end_time.hour(), minute=end_time.minute()
        )

        self.accept()


class ImprovedEnhancedIntegrityCheckTab(QWidget):
    """
    Improved version of the EnhancedIntegrityCheckTab with a more streamlined UI.
    """

    # Signal when directory is selected (for coordination with other tabs)
    directory_selected = pyqtSignal(str)

    def __init__(
        self,
        view_model: EnhancedIntegrityCheckViewModel,
        parent: Optional[QWidget] = None,
    ) -> None:
        """
        Initialize the improved integrity check tab.

        Args:
            view_model: The ViewModel instance to use
            parent: Optional parent widget
        """
        super().__init__(parent)

        if not isinstance(view_model, EnhancedIntegrityCheckViewModel):
            raise TypeError(
                "view_model must be an instance of EnhancedIntegrityCheckViewModel"
            )

        self.view_model = view_model

        # Create UI components
        self._setup_ui()

        # Connect signals from view model
        self._connect_signals()

        # Initial UI update
        self._update_ui_from_view_model()

    def _setup_ui(self) -> None:
        """Set up the streamlined user interface."""
        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(10)

        # Top section: Simplified Controls
        controls_section = QWidget()
        controls_layout = QVBoxLayout(controls_section)
        controls_layout.setContentsMargins(5, 5, 5, 5)

        # Main actions bar (directory selection, scan button, quick select)
        main_actions = QHBoxLayout()

        # Directory selection
        directory_layout = QHBoxLayout()
        directory_layout.addWidget(QLabel("Directory:"))
        self.directory_edit = QLineEdit()
        self.directory_edit.setReadOnly(True)
        self.directory_browse_button = QPushButton("Browse...")
        self.directory_browse_button.setToolTip(
            "Select directory to scan for GOES imagery"
        )
        directory_layout.addWidget(self.directory_edit, 1)  # Give stretch priority
        directory_layout.addWidget(self.directory_browse_button)

        main_actions.addLayout(
            directory_layout, 3
        )  # Give directory selection more space

        # Date selection
        date_layout = QHBoxLayout()
        date_layout.addWidget(QLabel("Date Range:"))
        self.date_range_label = QLabel("Yesterday (00:00 - 23:59)")
        self.date_range_label.setStyleSheet("font-weight: bold;")
        self.date_select_button = QPushButton("Change...")
        self.date_select_button.setToolTip("Select date range to scan")
        date_layout.addWidget(self.date_range_label, 1)
        date_layout.addWidget(self.date_select_button)

        main_actions.addLayout(date_layout, 2)

        # Scan button
        self.scan_button = QPushButton("Verify Integrity")
        self.scan_button.setMinimumHeight(40)
        self.scan_button.setStyleSheet("QPushButton { font-weight: bold; }")
        main_actions.addWidget(self.scan_button, 1)

        controls_layout.addLayout(main_actions)

        # Expandable advanced options
        self.advanced_options = QGroupBox("Advanced Options")
        self.advanced_options.setCheckable(True)
        self.advanced_options.setChecked(False)  # Collapsed by default

        advanced_layout = QGridLayout(self.advanced_options)

        # Satellite pattern
        advanced_layout.addWidget(QLabel("Satellite:"), 0, 0)
        self.satellite_combo = QComboBox()
        for pattern in SatellitePattern:
            self.satellite_combo.addItem(pattern.name.replace("_", "-"), pattern.value)
        advanced_layout.addWidget(self.satellite_combo, 0, 1)

        # Interval
        advanced_layout.addWidget(QLabel("Interval:"), 0, 2)
        self.interval_spinbox = QSpinBox()
        self.interval_spinbox.setRange(0, 60)
        self.interval_spinbox.setValue(0)
        self.interval_spinbox.setSuffix(" min")
        self.interval_spinbox.setSpecialValueText("Auto-detect")
        advanced_layout.addWidget(self.interval_spinbox, 0, 3)

        # Source
        advanced_layout.addWidget(QLabel("Data Source:"), 1, 0)
        self.source_combo = QComboBox()
        self.source_combo.addItem("Auto (Try All)", "auto")
        self.source_combo.addItem("Amazon S3", "s3")
        self.source_combo.addItem("NOAA CDN", "cdn")
        advanced_layout.addWidget(self.source_combo, 1, 1)

        # Checkboxes
        self.force_rescan_checkbox = QCheckBox("Force Rescan")
        self.force_rescan_checkbox.setToolTip(
            "Ignore cached results and perform a new scan"
        )
        advanced_layout.addWidget(self.force_rescan_checkbox, 1, 2)

        self.auto_download_checkbox = QCheckBox("Auto-Download Missing Files")
        self.auto_download_checkbox.setToolTip(
            "Automatically download missing files after scan"
        )
        advanced_layout.addWidget(self.auto_download_checkbox, 1, 3)

        controls_layout.addWidget(self.advanced_options)

        main_layout.addWidget(controls_section)

        # Middle section: Progress and status
        progress_section = QWidget()
        progress_layout = QVBoxLayout(progress_section)
        progress_layout.setContentsMargins(0, 0, 0, 0)

        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        progress_layout.addWidget(self.progress_bar)

        # Status message with action buttons
        status_layout = QHBoxLayout()

        self.status_label = QLabel("Ready to scan")
        self.status_label.setStyleSheet("QLabel { font-weight: bold; }")
        status_layout.addWidget(self.status_label, 1)  # Give stretch priority

        # Cancel button (only shown during operations)
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.setVisible(False)  # Hidden by default
        status_layout.addWidget(self.cancel_button)

        progress_layout.addLayout(status_layout)

        main_layout.addWidget(progress_section)

        # Bottom section: Results with action buttons
        results_section = QWidget()
        results_layout = QVBoxLayout(results_section)
        results_layout.setContentsMargins(0, 0, 0, 0)
        results_layout.setSpacing(5)  # Tighter spacing

        # Title, search filter, and action buttons for results
        results_header = QHBoxLayout()

        results_header.addWidget(QLabel("<b>Missing Timestamps</b>"))

        # Add search filter
        search_layout = QHBoxLayout()
        search_layout.addWidget(QLabel("Filter:"))
        self.search_edit = QLineEdit()
        self.search_edit.setPlaceholderText("Search timestamps, status, or paths...")
        self.search_edit.setClearButtonEnabled(True)
        self.search_edit.textChanged.connect(self._filter_table)
        search_layout.addWidget(self.search_edit)

        results_header.addLayout(search_layout, 1)  # Give search field stretch priority

        # Action buttons
        self.download_button = QPushButton("Download Missing")
        self.download_button.setEnabled(False)
        results_header.addWidget(self.download_button)

        self.export_button = QPushButton("Export Report")
        self.export_button.setEnabled(False)
        results_header.addWidget(self.export_button)

        self.cache_button = QPushButton("Cache Info")
        results_header.addWidget(self.cache_button)

        results_layout.addLayout(results_header)

        # Table view
        self.table_view = QTableView()
        self.table_model = EnhancedMissingTimestampsModel()
        self.table_view.setModel(self.table_model)

        # Configure table view
        horizontal_header = self.table_view.horizontalHeader()
        if horizontal_header is not None:
            # Set specific column widths
            horizontal_header.setSectionResizeMode(QHeaderView.ResizeMode.Interactive)

            # Timestamp column (fixed width)
            horizontal_header.setSectionResizeMode(
                0, QHeaderView.ResizeMode.ResizeToContents
            )

            # Satellite column (fixed narrow width)
            horizontal_header.setSectionResizeMode(
                1, QHeaderView.ResizeMode.ResizeToContents
            )

            # Source column (narrow)
            horizontal_header.setSectionResizeMode(
                2, QHeaderView.ResizeMode.ResizeToContents
            )

            # Status column (medium width)
            horizontal_header.setSectionResizeMode(
                3, QHeaderView.ResizeMode.ResizeToContents
            )

            # Progress column (very narrow)
            horizontal_header.setSectionResizeMode(
                4, QHeaderView.ResizeMode.ResizeToContents
            )

            # Path column (stretches to fill remaining space, but not too much)
            horizontal_header.setSectionResizeMode(5, QHeaderView.ResizeMode.Stretch)

            # Set maximum widths for certain columns
            self.table_view.setColumnWidth(0, 150)  # Timestamp
            self.table_view.setColumnWidth(1, 80)  # Satellite
            self.table_view.setColumnWidth(2, 70)  # Source
            self.table_view.setColumnWidth(3, 160)  # Status
            self.table_view.setColumnWidth(4, 70)  # Progress

        vertical_header = self.table_view.verticalHeader()
        if vertical_header is not None:
            vertical_header.setVisible(False)

        self.table_view.setSelectionBehavior(QTableView.SelectionBehavior.SelectRows)
        self.table_view.setAlternatingRowColors(True)
        self.table_view.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.table_view.customContextMenuRequested.connect(self._show_context_menu)

        results_layout.addWidget(self.table_view)

        # Add status bar for table information
        self.table_status_bar = QLabel("0 items")
        self.table_status_bar.setStyleSheet("QLabel { color: #666; }")
        results_layout.addWidget(self.table_status_bar)

        main_layout.addWidget(results_section, 1)  # Give table stretch priority

        # Connect widget signals
        self.directory_browse_button.clicked.connect(self._browse_directory)
        self.date_select_button.clicked.connect(self._select_date_range)
        self.scan_button.clicked.connect(self._start_scan)
        self.cancel_button.clicked.connect(self._cancel_operation)
        self.download_button.clicked.connect(self._download_missing)
        self.export_button.clicked.connect(self._export_report)
        self.cache_button.clicked.connect(self._show_cache_info)

        # Set date range to yesterday by default
        self._update_date_range_to_yesterday()

        # Right-click menu setup for table
        self.table_menu = QMenu(self)
        self.download_action = QAction("Download Selected", self)
        self.download_action.triggered.connect(self._download_selected)
        self.table_menu.addAction(self.download_action)

        self.view_details_action = QAction("View Error Details", self)
        self.view_details_action.triggered.connect(self._view_error_details)
        self.table_menu.addAction(self.view_details_action)

        self.open_folder_action = QAction("Open Containing Folder", self)
        self.open_folder_action.triggered.connect(self._open_containing_folder)
        self.table_menu.addAction(self.open_folder_action)

    def _connect_signals(self) -> None:
        """Connect signals from the view model."""
        self.view_model.status_updated.connect(self._update_status)
        self.view_model.status_type_changed.connect(self._update_status_type)
        self.view_model.progress_updated.connect(self._update_progress)
        self.view_model.missing_items_updated.connect(self._update_missing_items)
        self.view_model.scan_completed.connect(self._handle_scan_completed)
        self.view_model.download_progress_updated.connect(
            self._update_download_progress
        )
        self.view_model.download_item_updated.connect(self._update_download_item)

    def _update_ui_from_view_model(self) -> None:
        """Update UI elements with the current state from the view model."""
        # Directory
        self.directory_edit.setText(str(self.view_model.base_directory))

        # Date range
        self._update_date_range_label()

        # Options
        self.interval_spinbox.setValue(self.view_model.interval_minutes)

        # Find index for the selected pattern
        pattern_index = 0
        for i in range(self.satellite_combo.count()):
            if (
                self.satellite_combo.itemData(i)
                == self.view_model.selected_pattern.value
            ):
                pattern_index = i
                break
        self.satellite_combo.setCurrentIndex(pattern_index)

        # Set source
        source_index = 0  # Default to "auto"
        if self.view_model.preferred_source == FetchSource.S3:
            source_index = 1
        elif self.view_model.preferred_source == FetchSource.CDN:
            source_index = 2
        self.source_combo.setCurrentIndex(source_index)

        # Checkboxes
        self.force_rescan_checkbox.setChecked(self.view_model.force_rescan)
        self.auto_download_checkbox.setChecked(self.view_model.auto_download)

        # Status and progress
        self.status_label.setText(self.view_model.status_message)
        self._update_button_states()

    def _update_button_states(self) -> None:
        """Update button enabled states based on the view model state."""
        is_scanning = self.view_model.is_scanning
        is_downloading = self.view_model.is_downloading
        has_missing_items = self.view_model.has_missing_items

        # Scan button enabled when not scanning or downloading
        self.scan_button.setEnabled(self.view_model.can_start_scan)

        # Cancel button visible during scanning or downloading
        self.cancel_button.setVisible(is_scanning or is_downloading)

        # Download button enabled when there are missing items and not currently downloading
        self.download_button.setEnabled(has_missing_items and not is_downloading)

        # Export button enabled when there are missing items
        self.export_button.setEnabled(has_missing_items)

    def _update_date_range_to_yesterday(self) -> None:
        """Update the date range to yesterday (full day)."""
        yesterday = datetime.now() - timedelta(days=1)
        yesterday_start = yesterday.replace(hour=0, minute=0, second=0, microsecond=0)
        yesterday_end = yesterday.replace(hour=23, minute=59, second=59, microsecond=0)

        # Update view model
        self.view_model.start_date = yesterday_start
        self.view_model.end_date = yesterday_end

        # Update UI
        self._update_date_range_label()

    def _update_date_range_label(self) -> None:
        """Update the date range label with the current date range."""
        start_date = self.view_model.start_date
        end_date = self.view_model.end_date

        # Format dates for display
        if start_date.date() == end_date.date():
            # Same day
            date_str = start_date.strftime("%Y-%m-%d")
            time_str = f"{start_date.strftime('%H:%M')} - {end_date.strftime('%H:%M')}"
            self.date_range_label.setText(f"{date_str} ({time_str})")
        else:
            # Different days
            start_str = start_date.strftime("%Y-%m-%d %H:%M")
            end_str = end_date.strftime("%Y-%m-%d %H:%M")
            self.date_range_label.setText(f"{start_str} → {end_str}")

    def _browse_directory(self) -> None:
        """Open a dialog to select the base directory."""
        directory = QFileDialog.getExistingDirectory(
            self, "Select Directory", str(self.view_model.base_directory)
        )
        if directory:
            self.view_model.base_directory = Path(directory)
            self.directory_edit.setText(directory)
            self.directory_selected.emit(directory)

    def _select_date_range(self) -> None:
        """Open dialog to select date range."""
        dialog = QuickDateDialog(self)

        # Initialize with current values
        if dialog.exec():
            # Update view model
            self.view_model.start_date = dialog.start_date
            self.view_model.end_date = dialog.end_date

            # Update UI
            self._update_date_range_label()

    def _start_scan(self) -> None:
        """Start the scan operation."""
        # Update view model parameters from UI
        self.view_model.interval_minutes = self.interval_spinbox.value()

        pattern_value = self.satellite_combo.currentData()
        self.view_model.selected_pattern = SatellitePattern(pattern_value)

        # Set preferred source
        source = self.source_combo.currentData()
        if source == "s3":
            self.view_model.preferred_source = FetchSource.S3
        elif source == "cdn":
            self.view_model.preferred_source = FetchSource.CDN
        else:
            self.view_model.preferred_source = FetchSource.AUTO

        self.view_model.force_rescan = self.force_rescan_checkbox.isChecked()
        self.view_model.auto_download = self.auto_download_checkbox.isChecked()

        # Start scan
        self.view_model.start_scan()

        # Update UI
        self._update_button_states()

    def _cancel_operation(self) -> None:
        """Cancel the ongoing operation."""
        if self.view_model.is_scanning:
            self.view_model.cancel_scan()
        elif self.view_model.is_downloading:
            self.view_model.cancel_downloads()

        self.status_label.setText("Cancelling...")

    def _download_missing(self) -> None:
        """Start downloading all missing files."""
        if not self.view_model.has_missing_items:
            QMessageBox.information(
                self, "No Missing Files", "There are no missing files to download."
            )
            return

        # Start downloads
        self.view_model.start_downloads()

        # Update UI
        self._update_button_states()

    def _download_selected(self) -> None:
        """Download the selected missing files."""
        selection_model = self.table_view.selectionModel()
        if selection_model is None:
            return

        selected_indexes = selection_model.selectedRows()
        if not selected_indexes:
            return

        selected_indices = [index.row() for index in selected_indexes]
        # Use download_items instead of download_selected_items
        if hasattr(self.view_model, "download_items"):
            self.view_model.download_items(selected_indices)
        elif hasattr(self.view_model, "download_selected_items"):
            self.view_model.download_selected_items(selected_indices)

        # Update UI
        self._update_button_states()

    def _view_error_details(self) -> None:
        """Show error details for the selected item."""
        selection_model = self.table_view.selectionModel()
        if selection_model is None:
            return

        selected_indexes = selection_model.selectedRows()
        if not selected_indexes:
            return

        row = selected_indexes[0].row()
        if row < 0 or row >= len(self.view_model.missing_items):
            return

        item = self.view_model.missing_items[row]
        if not hasattr(item, "download_error") or not item.download_error:
            return

        QMessageBox.critical(
            self,
            "Download Error Details",
            f"Timestamp: {item.timestamp.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
            f"Error: {item.download_error}",
        )

    def _open_containing_folder(self) -> None:
        """Open the folder containing the selected file."""
        selection_model = self.table_view.selectionModel()
        if selection_model is None:
            return

        selected_indexes = selection_model.selectedRows()
        if not selected_indexes:
            return

        row = selected_indexes[0].row()
        if row < 0 or row >= len(self.view_model.missing_items):
            return

        item = self.view_model.missing_items[row]
        if not hasattr(item, "local_path") or not item.local_path:
            return

        try:
            path = Path(item.local_path)
            if path.exists():
                # Open the folder containing the file
                import platform
                import subprocess

                if platform.system() == "Windows":
                    subprocess.run(["explorer", "/select,", str(path)])
                elif platform.system() == "Darwin":  # macOS
                    subprocess.run(["open", "-R", str(path)])
                else:  # Linux
                    subprocess.run(["xdg-open", str(path.parent)])
        except Exception as e:
            LOGGER.error(f"Error opening folder: {e}")
            QMessageBox.warning(self, "Error", f"Could not open folder: {e}")

    def _export_report(self) -> None:
        """Export a report of missing timestamps."""
        if not self.view_model.has_missing_items:
            QMessageBox.information(
                self, "No Data", "There are no missing files to export."
            )
            return

        # Get file path from user
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Report",
            os.path.join(os.path.expanduser("~"), "missing_timestamps.csv"),
            "CSV Files (*.csv);;All Files (*)",
        )

        if not file_path:
            return

        try:
            # Generate report
            with open(file_path, "w") as f:
                # Write header
                f.write("Timestamp,Satellite,Filename,Status,Path\n")

                # Write data
                for item in self.view_model.missing_items:
                    status = "Downloaded" if item.is_downloaded else "Missing"
                    if item.download_error:
                        status = f"Error: {item.download_error.replace(',', ' ')}"

                    satellite = getattr(item, "satellite", None)
                    satellite_name = satellite.name if satellite else "Unknown"

                    f.write(
                        f"{item.timestamp.strftime('%Y-%m-%d %H:%M:%S')},"
                        f"{satellite_name},"
                        f"{item.expected_filename},"
                        f"{status},"
                        f"{item.local_path or ''}\n"
                    )

            QMessageBox.information(
                self, "Export Complete", f"Report exported to {file_path}"
            )

        except Exception as e:
            LOGGER.error(f"Error exporting report: {e}")
            QMessageBox.critical(self, "Export Error", f"Error exporting report: {e}")

    def _show_cache_info(self) -> None:
        """Show the cache information dialog."""
        dialog = CacheInfoDialog(self.view_model, self)
        dialog.exec()

    def _show_context_menu(self, position: QPoint) -> None:
        """Show context menu for table view."""
        global_pos = self.table_view.mapToGlobal(position)

        # Check if there's a valid selection
        selection_model = self.table_view.selectionModel()
        if selection_model is None:
            return

        selected_indexes = selection_model.selectedRows()
        if not selected_indexes:
            return

        # Enable/disable actions based on selected item
        row = selected_indexes[0].row()
        if row >= 0 and row < len(self.view_model.missing_items):
            item = self.view_model.missing_items[row]

            # Error details
            self.view_details_action.setEnabled(
                hasattr(item, "download_error") and bool(item.download_error)
            )

            # Download
            self.download_action.setEnabled(
                not getattr(item, "is_downloaded", False)
                and not getattr(item, "is_downloading", False)
            )

            # Open folder
            self.open_folder_action.setEnabled(
                hasattr(item, "local_path")
                and bool(item.local_path)
                and getattr(item, "is_downloaded", False)
            )

            self.table_menu.exec(global_pos)

    # --- Slot handlers for view model signals ---

    def _update_status(self, message: str) -> None:
        """Update the status message."""
        self.status_label.setText(message)

    def _update_status_type(self, status: ScanStatus) -> None:
        """Update the status type and button states."""
        self._update_button_states()

    def _update_progress(self, current: int, total: int, eta: float) -> None:
        """Update the progress bar."""
        progress_percent = int((current / total) * 100) if total > 0 else 0
        self.progress_bar.setValue(progress_percent)

        # Format ETA if available
        if eta > 0:
            eta_minutes = int(eta / 60)
            eta_seconds = int(eta % 60)
            self.progress_bar.setFormat(
                f"{progress_percent}% - ETA: {eta_minutes}m {eta_seconds}s"
            )
        else:
            self.progress_bar.setFormat(f"{progress_percent}%")

    def _update_missing_items(self, items: List[MissingTimestamp]) -> None:
        """Update the table model with missing items."""
        self.table_model.setItems(items)
        self._update_button_states()

        # Update status bar
        if items:
            downloaded = sum(
                1 for item in items if getattr(item, "is_downloaded", False)
            )
            downloading = sum(
                1 for item in items if getattr(item, "is_downloading", False)
            )
            errors = sum(1 for item in items if getattr(item, "download_error", False))
            missing = len(items) - downloaded - downloading - errors

            status_text = f"{len(items)} items total • "
            if downloaded > 0:
                status_text += f"{downloaded} downloaded • "
            if downloading > 0:
                status_text += f"{downloading} downloading • "
            if errors > 0:
                status_text += f"{errors} errors • "
            if missing > 0:
                status_text += f"{missing} missing"

            # Remove trailing separator if present
            if status_text.endswith(" • "):
                status_text = status_text[:-3]

            self.table_status_bar.setText(status_text)
        else:
            self.table_status_bar.setText("0 items")

    def _handle_scan_completed(self, success: bool, message: str) -> None:
        """Handle scan completion."""
        if success:
            # Reset progress bar to show 100%
            self.progress_bar.setValue(100)
            self.progress_bar.setFormat("100%")

            # Show success message
            if self.view_model.missing_count > 0:
                QMessageBox.information(
                    self,
                    "Scan Complete",
                    f"Found {self.view_model.missing_count} missing timestamps "
                    f"out of {self.view_model.total_expected} expected.",
                )
            else:
                QMessageBox.information(
                    self,
                    "Scan Complete",
                    "No missing timestamps found. All files are present!",
                )
        else:
            # Show error message
            QMessageBox.critical(self, "Scan Error", message)

        # Update button states
        self._update_button_states()

    def _update_download_progress(self, current: int, total: int) -> None:
        """Update the progress bar for downloads."""
        progress_percent = int((current / total) * 100) if total > 0 else 0
        self.progress_bar.setValue(progress_percent)
        self.progress_bar.setFormat(f"{progress_percent}% - {current}/{total} files")

    def _update_download_item(self, index: int, item: MissingTimestamp) -> None:
        """Update a specific item in the table model."""
        self.table_model.updateItem(index, item)

        # Process events to ensure UI updates immediately
        QApplication.processEvents()

        # Update status bar counts after item update
        if self.view_model.missing_items:
            items = self.view_model.missing_items
            downloaded = sum(
                1 for item in items if getattr(item, "is_downloaded", False)
            )
            downloading = sum(
                1 for item in items if getattr(item, "is_downloading", False)
            )
            errors = sum(1 for item in items if getattr(item, "download_error", False))
            missing = len(items) - downloaded - downloading - errors

            status_text = f"{len(items)} items total • "
            if downloaded > 0:
                status_text += f"{downloaded} downloaded • "
            if downloading > 0:
                status_text += f"{downloading} downloading • "
            if errors > 0:
                status_text += f"{errors} errors • "
            if missing > 0:
                status_text += f"{missing} missing"

            # Remove trailing separator if present
            if status_text.endswith(" • "):
                status_text = status_text[:-3]

            self.table_status_bar.setText(status_text)

    def _filter_table(self, text: str) -> None:
        """Filter the table based on search text."""
        if not hasattr(self, "_proxy_model"):
            # Create proxy model for filtering
            self._proxy_model = QSortFilterProxyModel(self)
            self._proxy_model.setSourceModel(self.table_model)
            self._proxy_model.setFilterCaseSensitivity(
                Qt.CaseSensitivity.CaseInsensitive
            )
            self._proxy_model.setFilterKeyColumn(-1)  # Search across all columns
            self.table_view.setModel(self._proxy_model)

            # Re-apply column widths to the view with the proxy model
            header = self.table_view.horizontalHeader()
            if header:
                self.table_view.setColumnWidth(0, 150)  # Timestamp
                self.table_view.setColumnWidth(1, 80)  # Satellite
                self.table_view.setColumnWidth(2, 70)  # Source
                self.table_view.setColumnWidth(3, 160)  # Status
                self.table_view.setColumnWidth(4, 70)  # Progress
                header.setSectionResizeMode(5, QHeaderView.ResizeMode.Stretch)

        # Apply filter
        self._proxy_model.setFilterFixedString(text)
